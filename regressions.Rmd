---
title: "MS&E246Project"
author: "Alec Powell, Frank Fang, Cam Najmabadi"
date: "January 29, 2016"
output: html_document
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
mydata <- read.csv("SBA_Loan_data.csv")
# Making new column boolean for default status
mydata$defaulted <- mydata$GrossChargeOffAmount > 0

#take out status=EXEMPT and status=CANCLD
mydata <- subset(mydata, LoanStatus!="EXEMPT"&LoanStatus!="CANCLD"&!is.na(BusinessType))


#Calculating overall percentage of loans defaulted (in progress)
sum(!mydata$defaulted)/nrow(mydata)

#Calcluate percentage of loans defaulted by state
## which states have the most defaults?
state_v_default <- xtabs(~ BorrState + defaulted, data = mydata)
state_v_default <- as.data.frame.matrix(state_v_default)
state_v_default[-1,]
state_v_default$percentage <- state_v_default[,2]/(state_v_default[,1]+state_v_default[,2]) 
#only_defaults <- mydata[which(mydata$GrossChargeOffAmount > 0),]
#frank's old code
# s <- table(only_defaults$ProjectState)
# tot_state <- table(mydata$ProjectState)
# s <- as.data.frame(s)
# tot_state <- as.data.frame(tot_state)
# names(s)[1] <- 'ProjectState'
# s[2] <- s[2] / tot_state[2] ##proportion of projects per state that default on a loan
# s<- s[order(-s$Freq),]
```
Now, onto years. Which years were the most defaults observed?
(more text here)

```{r}

year_v_default <- xtabs(~ ApprovalFiscalYear + defaulted, data = mydata)
year_v_default <- as.data.frame.matrix(year_v_default)
year_v_default$percentage <- year_v_default[,2]/(year_v_default[,1]+year_v_default[,2]) 

#high_default_years <- row.names(year_v_default[order(year_v_default$percentage, decreasing = TRUE)])

#classifying/indicator based on business type
b_type_table <- xtabs(~ BusinessType + defaulted, data = mydata)
b_type_table <- as.data.frame.matrix(b_type_table)
b_type_table$percentage <- b_type_table[,2]/(b_type_table[,1]+b_type_table[,2]) 

#Make indicator variables
top_10_default_states <- row.names(state_v_default[order(state_v_default$percentage,decreasing=T)[1:10],])
top_10_default_years <- row.names(year_v_default[order(year_v_default$percentage,decreasing = T)[1:10],])
mydata$badState <- mydata$BorrState %in% top_10_default_states
mydata$badYear <- mydata$ApprovalFiscalYear %in% top_10_default_years


#testing for linear and logistic?
set.seed(100)

mixed.set <- mydata[sample(nrow(mydata)),]
train <- mixed.set[1:38364,]
test <- mixed.set[38365:54807,]


#go through and take out states that aren't as relevant (calc # of defaults per state)
drops <- c("Program", "BorrName","BorrStreet","BorrCity","BorrZip","CDC_Name","CDC_Street","CDC_City","CDC_Zip","ThirdPartyLender_Name","ThirdPartyLender_City","ThirdPartyLender_State","ThirdPartyDollars","Delivery Method","ProjectCounty","ApprovalDate","ChargeOffDate","NaicsDescription","BorrState","CDC_State","ProjectState","LoanStatus","subpgmdesc","NaicsCode","InitialInterestRate")

train_pruned <- train[,!(names(train) %in% drops)]
test_pruned <- test[,!(names(test) %in% drops)]


# Multiple Linear Regression
myvars <- names(test_pruned) %in% c("defaulted")
lm.fit <- lm(GrossChargeOffAmount~., data = test_pruned[!myvars])
summary(lm.fit) # show results

pairs(test_pruned)

myvars_new <- names(train_pruned) %in% c("defaulted","DeliveryMethod","BusinessType")
train_pruned_subset <- subset(train_pruned, select = !myvars_new)
test_pruned_subset <- subset(test_pruned, select = !myvars_new)

#Lasso??
grid=10^seq(2,-2,length=100)
#compute min lambda to use for lasso.train
lasso.mod=cv.glmnet(as.matrix(train_pruned_subset),train_pruned$GrossChargeOffAmount,alpha=1,lambda=grid)
plot(lasso.mod)

#lasso.train=glmnet(as.matrix(train_pruned_subset),train_pruned$GrossChargeOffAmount,alpha=1,lambda=0.01)
#plot(lasso.train$glmnet.fit)

#doesn't work
bestlam <- lasso.mod$lambda.min
lasso.pred <- predict(lasso.mod,s=bestlam,newx=test_pruned)
mse <-	mean((lasso.pred-y.test)^2)


# Logistic Regression

glm.fit <- glm(defaulted~.-GrossChargeOffAmount, data = train_pruned, family = "binomial")
glm.probs <- predict.glm(glm.fit, newdata = test_pruned, type = "response")

#confusion matrix--need to repeat over iterations every 0.05 increment in _classification_threshold_
CLASSIFICATION_THRESHOLD = 0.1
glm.pred = rep("No default",length(glm.probs))
glm.pred [glm.probs > CLASSIFICATION_THRESHOLD] = "Yes-Default"
glm.test.conf <- table(glm.pred, test_pruned$defaulted)

glm.predict.ratio <- (glm.test.conf[1,1]+glm.test.conf[2,2])/(glm.test.conf[1,1]+glm.test.conf[1,2]+glm.test.conf[2,1]+glm.test.conf[2,2])

#True postive and false positive rates (for ROC curve)
glm.tpr <- glm.test.conf[2,2]/(glm.test.conf[2,2]+glm.test.conf[1,2])
glm.fpr <- glm.test.conf[1,2]/(glm.test.conf[1,2]+glm.test.conf[1,1])

plot(glm.fpr,glm.tpr)

```

Now for some LDA, with an ROC curve hopefully:

```{r}
library(MASS)
lda.fit = lda(defaulted~(GrossApproval+badState+badYear), data = train_pruned)

lda.fit.predict = predict(lda.fit, newdata = test_pruned, type = "response")
#lda.pred = rep("No default",length(lda.fit.predict))
#lda.pred [lda.fit.predict > CLASSIFICATION_THRESHOLD] = "Yes-Default"
#lda.test.conf <- table(lda.pred, test_pruned$defaulted)

lda.test.conf = table(lda.fit.predict$class, test_pruned$defaulted)
print(lda.test.conf)

lda.predict.ratio = (lda.test.conf[1,1]+lda.test.conf[2,2])/(lda.test.conf[1,1]+lda.test.conf[1,2]+lda.test.conf[2,1]+lda.test.conf[2,2])
print(lda.predict.ratio)

lda.tpr <- lda.test.conf[2,2]/(lda.test.conf[2,2]+lda.test.conf[1,2])
lda.fpr <- lda.test.conf[1,2]/(lda.test.conf[1,2]+lda.test.conf[1,1])
plot(lda.fpr,lda.tpr)

# number of predicted defaults:
lda.pred.t = sum(lda.fit.predict$posterior[,2] >= CLASSIFICATION_THRESHOLD)
# number of predicted non-defaults:
lda.pred.f = sum(lda.fit.predict$posterior[,2] < CLASSIFICATION_THRESHOLD)
print(lda.pred.t)
print(lda.pred.f)

```

Lasso?

```{r}
library(glmnet)
lasso.mod=glmnet(x[train_X,],y[train_X],alpha=1,lambda=grid)
plot(lasso.mod)

```

You can also embed plots, for example:

```{r, echo=FALSE}
plot(cars)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
